
 MAX COMPLEXITY IS 2 

INFO - [CUDA_optimize] - Running Branch Distribution with cutoff of 0 
INFO - [CUDA_optimize] - Running Global to Shared on array params: []

addSubArray1:
    Bound: 7 + 1761 max(0, w)
    Number of LP variables: 1050
    Number of LP constraints: 965
    Maximum focus functions in use: 51
    LP solver time: 0.004s
    

addSubArray1:
    Bound: 7 + 1065 max(0, w)
    Number of LP variables: 944
    Number of LP constraints: 839
    Maximum focus functions in use: 53
    LP solver time: 0.004s
    
INFO - [OptDriver] - Greedy best cutoff is 0

addSubArray1:
    Bound: 7 + 1761 max(0, w)
    Number of LP variables: 1050
    Number of LP constraints: 965
    Maximum focus functions in use: 51
    LP solver time: 0.004s
    

INFO - [CUDA_optimize] - Running Branch Distribution with cutoff of 0 
INFO - [CUDA_optimize] - Running Global to Shared on array params: [A]

INFO - [CUDA_optimize] - Running Branch Distribution with cutoff of 0 
INFO - [CUDA_optimize] - Running Global to Shared on array params: [B]
INFO - [OptDriver] - Checking unused params for greedy improvement
INFO - [OptDriver] - Analysis for Branch Distribution of 0 
INFO - [OptDriver] - Running Global to Shared on array params: [A] 

addSubArray1:
    Bound: 57 + 1044 max(0, w)
    Number of LP variables: 1162
    Number of LP constraints: 1011
    Maximum focus functions in use: 65
    LP solver time: 0.005s
    
INFO - [OptDriver] - Analysis for Branch Distribution of 0 
INFO - [OptDriver] - Running Global to Shared on array params: [B] 

addSubArray1:
    Bound: 495 + 309 max(0, w)
    Number of LP variables: 944
    Number of LP constraints: 839
    Maximum focus functions in use: 53
    LP solver time: 0.004s
    
INFO - [OptDriver] - Greedy improvement detected, setting Global to Shared to [B] 

INFO - [CUDA_optimize] - Running Branch Distribution with cutoff of 0 
INFO - [CUDA_optimize] - Running Global to Shared on array params: [A,B]
INFO - [OptDriver] - Checking unused params for greedy improvement
INFO - [OptDriver] - Analysis for Branch Distribution of 0 
INFO - [OptDriver] - Running Global to Shared on array params: [B,A] 

addSubArray1:
    Bound: 545 + 288 max(0, w)
    Number of LP variables: 1162
    Number of LP constraints: 1011
    Maximum focus functions in use: 65
    LP solver time: 0.005s
    
INFO - [OptDriver] - Greedy improvement detected, setting Global to Shared to [B,A] 
INFO - [OptDriver] - All possible array params have been moved to shared, terminating Greedy search
INFO - [OptDriver] - No Greedy improvement, we have found the best set
Best Code generation:

__global__ addSubArray1 ( int *A,  int *B,  int w,  int h) {

    signed long int lower_bound_A1;
    lower_bound_A1 = 0;
    __shared__ int A1[blockDim.x];
    A1[(blockIdx.x * blockDim.x) + threadIdx.x] = A[((blockIdx.x * blockDim.x)
                                                     + threadIdx.x)
                                                    + lower_bound_A1];
    signed long int lower_bound_B1;
    lower_bound_B1 = w
                     + (((w * threadIdx.x) * 2)
                        + ((w * (blockIdx.x * blockDim.x)) * 2));
    __shared__ int B1[blockDim.x];
    B1[(blockIdx.x * blockDim.x) + threadIdx.x] = B[((blockIdx.x * blockDim.x)
                                                     + threadIdx.x)
                                                    + lower_bound_B1];
    signed long int lower_bound_B2;
    lower_bound_B2 = ((w * threadIdx.x) * 2)
                     + ((w * (blockIdx.x * blockDim.x)) * 2);
    __shared__ int B2[blockDim.x];
    B2[(blockIdx.x * blockDim.x) + threadIdx.x] = B[((blockIdx.x * blockDim.x)
                                                     + threadIdx.x)
                                                    + lower_bound_B2];
    int i;
    for (i = 0; i < w; i = i + 1) {
    
        int j;
        j = (blockIdx.x * blockDim.x) + threadIdx.x;
        B2[(((2 * j) * w) + i) - lower_bound_B2] = B2
                                                   [(((2 * j) * w) + i)
                                                    - lower_bound_B2]
                                                   + A1[i - lower_bound_A1];
        B1[((((2 * j) + 1) * w) + i) - lower_bound_B1] = B1
                                                         [((((2 * j) + 1) * w)
                                                           + i)
                                                          - lower_bound_B1]
                                                         - A1
                                                           [i
                                                            - lower_bound_A1];
        if (threadIdx.x == 2) {
        
            B1[((((2 * j) + 1) * w) + i) - lower_bound_B1] = B1
                                                             [((((2 * j) + 1)
                                                                * w)
                                                               + i)
                                                              - lower_bound_B1]
                                                             + A1
                                                               [i
                                                                - lower_bound_A1];
        } else {
        
             
        }  
    }
    A1[((blockIdx.x * blockDim.x) + threadIdx.x) + lower_bound_A1] = A[(
                                                                    blockIdx.x
                                                                    * 
                                                                    blockDim.x)
                                                                    + threadIdx.x];
    B1[((blockIdx.x * blockDim.x) + threadIdx.x) + lower_bound_B1] = B[(
                                                                    blockIdx.x
                                                                    * 
                                                                    blockDim.x)
                                                                    + threadIdx.x];
    B2[((blockIdx.x * blockDim.x) + threadIdx.x) + lower_bound_B2] = B[(
                                                                    blockIdx.x
                                                                    * 
                                                                    blockDim.x)
                                                                    + threadIdx.x]; 
}

Optimal Branch Distribution cutoff: 0
Optimal Params to move to shared: [B,A]

545 + tick_z
Program Statistics:
    Total runtime: 102.126s
